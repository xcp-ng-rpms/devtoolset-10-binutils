diff -rup binutils.orig/bfd/elf-bfd.h binutils-2.35/bfd/elf-bfd.h
--- binutils.orig/bfd/elf-bfd.h	2020-07-30 15:04:05.366466702 +0100
+++ binutils-2.35/bfd/elf-bfd.h	2020-07-30 15:04:16.707393960 +0100
@@ -549,6 +549,16 @@ enum elf_target_os
   is_nacl	/* Native Client.  */
 };
 
+/* Used by bfd_sym_from_r_symndx to cache a small number of local
+   symbols.  */
+#define LOCAL_SYM_CACHE_SIZE 32
+struct sym_cache
+{
+  bfd *abfd;
+  unsigned long indx[LOCAL_SYM_CACHE_SIZE];
+  Elf_Internal_Sym sym[LOCAL_SYM_CACHE_SIZE];
+};
+
 /* ELF linker hash table.  */
 
 struct elf_link_hash_table
@@ -676,6 +686,9 @@ struct elf_link_hash_table
   /* A linked list of dynamic BFD's loaded in the link.  */
   struct elf_link_loaded_list *dyn_loaded;
 
+  /* Small local sym cache.  */
+  struct sym_cache sym_cache;
+
   /* Short-cuts to get to dynamic linker sections.  */
   asection *sgot;
   asection *sgotplt;
@@ -717,16 +730,6 @@ struct elf_link_hash_table
 /* Returns TRUE if the hash table is a struct elf_link_hash_table.  */
 #define is_elf_hash_table(htab)						\
   (((struct bfd_link_hash_table *) (htab))->type == bfd_link_elf_hash_table)
-
-/* Used by bfd_sym_from_r_symndx to cache a small number of local
-   symbols.  */
-#define LOCAL_SYM_CACHE_SIZE 32
-struct sym_cache
-{
-  bfd *abfd;
-  unsigned long indx[LOCAL_SYM_CACHE_SIZE];
-  Elf_Internal_Sym sym[LOCAL_SYM_CACHE_SIZE];
-};
 
 /* Constant information held for an ELF backend.  */
 
diff -rup binutils.orig/bfd/elf32-arm.c binutils-2.35/bfd/elf32-arm.c
--- binutils.orig/bfd/elf32-arm.c	2020-07-30 15:04:05.376466638 +0100
+++ binutils-2.35/bfd/elf32-arm.c	2020-07-30 15:04:16.708393953 +0100
@@ -3390,9 +3390,6 @@ struct elf32_arm_link_hash_table
     bfd_vma offset;
   } tls_ldm_got;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* For convenience in allocate_dynrelocs.  */
   bfd * obfd;
 
@@ -15316,7 +15313,7 @@ elf32_arm_check_relocs (bfd *abfd, struc
 	  if (r_symndx < symtab_hdr->sh_info)
 	    {
 	      /* A local symbol.  */
-	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	      isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
 					    abfd, r_symndx);
 	      if (isym == NULL)
 		return FALSE;
@@ -16871,7 +16868,8 @@ elf32_arm_size_dynamic_sections (bfd * o
 		  s->size += 4;
 		}
 
-	      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, symndx);
+	      isym = bfd_sym_from_r_symndx (&htab->root.sym_cache, ibfd,
+					    symndx);
 	      if (isym == NULL)
 		return FALSE;
 
diff -rup binutils.orig/bfd/elf32-bfin.c binutils-2.35/bfd/elf32-bfin.c
--- binutils.orig/bfd/elf32-bfin.c	2020-07-30 15:04:05.377466632 +0100
+++ binutils-2.35/bfd/elf32-bfin.c	2020-07-30 15:04:16.709393947 +0100
@@ -4791,16 +4791,6 @@ struct bfin_link_hash_entry
   struct bfin_pcrel_relocs_copied *pcrel_relocs_copied;
 };
 
-/* bfin ELF linker hash table.  */
-
-struct bfin_link_hash_table
-{
-  struct elf_link_hash_table root;
-
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-};
-
 #define bfin_hash_entry(ent) ((struct bfin_link_hash_entry *) (ent))
 
 static struct bfd_hash_entry *
@@ -4829,15 +4819,14 @@ bfin_link_hash_newfunc (struct bfd_hash_
 static struct bfd_link_hash_table *
 bfin_link_hash_table_create (bfd * abfd)
 {
-  struct bfin_link_hash_table *ret;
-  size_t amt = sizeof (struct bfin_link_hash_table);
+  struct elf_link_hash_table *ret;
+  size_t amt = sizeof (struct elf_link_hash_table);
 
   ret = bfd_zmalloc (amt);
   if (ret == NULL)
     return NULL;
 
-  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
-				      bfin_link_hash_newfunc,
+  if (!_bfd_elf_link_hash_table_init (ret, abfd, bfin_link_hash_newfunc,
 				      sizeof (struct elf_link_hash_entry),
 				      BFIN_ELF_DATA))
     {
@@ -4845,9 +4834,7 @@ bfin_link_hash_table_create (bfd * abfd)
       return NULL;
     }
 
-  ret->sym_cache.abfd = NULL;
-
-  return &ret->root.root;
+  return &ret->root;
 }
 
 /* The size in bytes of an entry in the procedure linkage table.  */
@@ -5418,10 +5405,6 @@ struct bfd_elf_special_section const elf
 
 #define bfd_elf32_bfd_is_local_label_name \
 					bfin_is_local_label_name
-#define bfin_hash_table(p) \
-  ((struct bfin_link_hash_table *) (p)->hash)
-
-
 
 #define elf_backend_create_dynamic_sections \
 					_bfd_elf_create_dynamic_sections
diff -rup binutils.orig/bfd/elf32-csky.c binutils-2.35/bfd/elf32-csky.c
--- binutils.orig/bfd/elf32-csky.c	2020-07-30 15:04:05.378466625 +0100
+++ binutils-2.35/bfd/elf32-csky.c	2020-07-30 15:04:16.709393947 +0100
@@ -1208,9 +1208,6 @@ struct csky_elf_link_hash_table
 {
   struct elf_link_hash_table elf;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* Data for R_CKCORE_TLS_LDM32 relocations.  */
   union
   {
@@ -2477,7 +2474,7 @@ csky_elf_check_relocs (bfd * abfd,
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
@@ -2584,7 +2581,7 @@ csky_elf_check_relocs (bfd * abfd,
 		  asection *s;
 		  Elf_Internal_Sym *loc_isym;
 
-		  loc_isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  loc_isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						    abfd, r_symndx);
 		  if (loc_isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elf32-hppa.c binutils-2.35/bfd/elf32-hppa.c
--- binutils.orig/bfd/elf32-hppa.c	2020-07-30 15:04:05.368466689 +0100
+++ binutils-2.35/bfd/elf32-hppa.c	2020-07-30 15:04:16.709393947 +0100
@@ -286,9 +286,6 @@ struct elf32_hppa_link_hash_table
   /* Set if we need a .plt stub to support lazy dynamic linking.  */
   unsigned int need_plt_stub:1;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* Data for LDM relocations.  */
   union
   {
@@ -1465,7 +1462,7 @@ elf32_hppa_check_relocs (bfd *abfd,
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->etab.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
@@ -4038,7 +4035,7 @@ elf32_hppa_relocate_section (bfd *output
 		else
 		  {
 		    Elf_Internal_Sym *isym
-		      = bfd_sym_from_r_symndx (&htab->sym_cache,
+		      = bfd_sym_from_r_symndx (&htab->etab.sym_cache,
 					       input_bfd, r_symndx);
 		    if (isym == NULL)
 		      return FALSE;
diff -rup binutils.orig/bfd/elf32-i386.c binutils-2.35/bfd/elf32-i386.c
--- binutils.orig/bfd/elf32-i386.c	2020-07-30 15:04:05.380466612 +0100
+++ binutils-2.35/bfd/elf32-i386.c	2020-07-30 15:04:16.710393941 +0100
@@ -1158,7 +1158,7 @@ elf_i386_tls_transition (struct bfd_link
 	    {
 	      Elf_Internal_Sym *isym;
 
-	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					    abfd, r_symndx);
 	      name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
 	    }
@@ -1251,7 +1251,7 @@ elf_i386_convert_load_reloc (bfd *abfd,
   else
     {
       local_ref = TRUE;
-      isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd,
+      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd,
 				    r_symndx);
       abs_symbol = isym->st_shndx == SHN_ABS;
     }
@@ -1529,7 +1529,7 @@ elf_i386_check_relocs (bfd *abfd,
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    goto error_return;
@@ -1859,7 +1859,7 @@ elf_i386_check_relocs (bfd *abfd,
 		  void **vpp;
 		  asection *s;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    goto error_return;
diff -rup binutils.orig/bfd/elf32-m32r.c binutils-2.35/bfd/elf32-m32r.c
--- binutils.orig/bfd/elf32-m32r.c	2020-07-30 15:04:05.370466676 +0100
+++ binutils-2.35/bfd/elf32-m32r.c	2020-07-30 15:04:16.710393941 +0100
@@ -1498,20 +1498,6 @@ struct elf_m32r_pcrel_relocs_copied
   bfd_size_type count;
 };
 
-/* m32r ELF linker hash table.  */
-
-struct elf_m32r_link_hash_table
-{
-  struct elf_link_hash_table root;
-
-  /* Short-cuts to get to dynamic linker sections.  */
-  asection *sdynbss;
-  asection *srelbss;
-
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-};
-
 /* Traverse an m32r ELF linker hash table.  */
 
 #define m32r_elf_link_hash_traverse(table, func, info)			\
@@ -1524,21 +1510,21 @@ struct elf_m32r_link_hash_table
 
 #define m32r_elf_hash_table(p) \
   (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
-  == M32R_ELF_DATA ? ((struct elf_m32r_link_hash_table *) ((p)->hash)) : NULL)
+  == M32R_ELF_DATA ? ((struct elf_link_hash_table *) ((p)->hash)) : NULL)
 
 /* Create an m32r ELF linker hash table.  */
 
 static struct bfd_link_hash_table *
 m32r_elf_link_hash_table_create (bfd *abfd)
 {
-  struct elf_m32r_link_hash_table *ret;
-  size_t amt = sizeof (struct elf_m32r_link_hash_table);
+  struct elf_link_hash_table *ret;
+  size_t amt = sizeof (struct elf_link_hash_table);
 
   ret = bfd_zmalloc (amt);
   if (ret == NULL)
     return NULL;
 
-  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+  if (!_bfd_elf_link_hash_table_init (ret, abfd,
 				      _bfd_elf_link_hash_newfunc,
 				      sizeof (struct elf_link_hash_entry),
 				      M32R_ELF_DATA))
@@ -1547,7 +1533,7 @@ m32r_elf_link_hash_table_create (bfd *ab
       return NULL;
     }
 
-  return &ret->root.root;
+  return &ret->root;
 }
 
 /* Create dynamic sections when linking against a dynamic object.  */
@@ -1555,7 +1541,7 @@ m32r_elf_link_hash_table_create (bfd *ab
 static bfd_boolean
 m32r_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
 {
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   flagword flags, pltflags;
   asection *s;
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
@@ -1578,7 +1564,7 @@ m32r_elf_create_dynamic_sections (bfd *a
     pltflags |= SEC_READONLY;
 
   s = bfd_make_section_anyway_with_flags (abfd, ".plt", pltflags);
-  htab->root.splt = s;
+  htab->splt = s;
   if (s == NULL
       || !bfd_set_section_alignment (s, bed->plt_alignment))
     return FALSE;
@@ -1598,7 +1584,7 @@ m32r_elf_create_dynamic_sections (bfd *a
       h = (struct elf_link_hash_entry *) bh;
       h->def_regular = 1;
       h->type = STT_OBJECT;
-      htab->root.hplt = h;
+      htab->hplt = h;
 
       if (bfd_link_pic (info)
 	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
@@ -1609,12 +1595,12 @@ m32r_elf_create_dynamic_sections (bfd *a
 					  bed->default_use_rela_p
 					  ? ".rela.plt" : ".rel.plt",
 					  flags | SEC_READONLY);
-  htab->root.srelplt = s;
+  htab->srelplt = s;
   if (s == NULL
       || !bfd_set_section_alignment (s, ptralign))
     return FALSE;
 
-  if (htab->root.sgot == NULL
+  if (htab->sgot == NULL
       && !_bfd_elf_create_got_section (abfd, info))
     return FALSE;
 
@@ -1669,7 +1655,7 @@ static bfd_boolean
 m32r_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
 				struct elf_link_hash_entry *h)
 {
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   bfd *dynobj;
   asection *s;
 
@@ -1796,7 +1782,7 @@ static bfd_boolean
 allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
 {
   struct bfd_link_info *info;
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   struct elf_dyn_relocs *p;
 
   if (h->root.type == bfd_link_hash_indirect)
@@ -1807,7 +1793,7 @@ allocate_dynrelocs (struct elf_link_hash
   if (htab == NULL)
     return FALSE;
 
-  if (htab->root.dynamic_sections_created
+  if (htab->dynamic_sections_created
       && h->plt.refcount > 0)
     {
       /* Make sure this symbol is output as a dynamic symbol.
@@ -1821,7 +1807,7 @@ allocate_dynrelocs (struct elf_link_hash
 
       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))
 	{
-	  asection *s = htab->root.splt;
+	  asection *s = htab->splt;
 
 	  /* If this is the first .plt entry, make room for the special
 	     first entry.  */
@@ -1847,10 +1833,10 @@ allocate_dynrelocs (struct elf_link_hash
 
 	  /* We also need to make an entry in the .got.plt section, which
 	     will be placed in the .got section by the linker script.  */
-	  htab->root.sgotplt->size += 4;
+	  htab->sgotplt->size += 4;
 
 	  /* We also need to make an entry in the .rel.plt section.  */
-	  htab->root.srelplt->size += sizeof (Elf32_External_Rela);
+	  htab->srelplt->size += sizeof (Elf32_External_Rela);
 	}
       else
 	{
@@ -1878,13 +1864,13 @@ allocate_dynrelocs (struct elf_link_hash
 	    return FALSE;
 	}
 
-      s = htab->root.sgot;
+      s = htab->sgot;
 
       h->got.offset = s->size;
       s->size += 4;
-      dyn = htab->root.dynamic_sections_created;
+      dyn = htab->dynamic_sections_created;
       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h))
-	htab->root.srelgot->size += sizeof (Elf32_External_Rela);
+	htab->srelgot->size += sizeof (Elf32_External_Rela);
     }
   else
     h->got.offset = (bfd_vma) -1;
@@ -1944,7 +1930,7 @@ allocate_dynrelocs (struct elf_link_hash
       if (!h->non_got_ref
 	  && ((h->def_dynamic
 	       && !h->def_regular)
-	      || (htab->root.dynamic_sections_created
+	      || (htab->dynamic_sections_created
 		  && (h->root.type == bfd_link_hash_undefweak
 		      || h->root.type == bfd_link_hash_undefined))))
 	{
@@ -1984,7 +1970,7 @@ static bfd_boolean
 m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
 				struct bfd_link_info *info)
 {
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   bfd *dynobj;
   asection *s;
   bfd_boolean relocs;
@@ -1998,10 +1984,10 @@ m32r_elf_size_dynamic_sections (bfd *out
   if (htab == NULL)
     return FALSE;
 
-  dynobj = htab->root.dynobj;
+  dynobj = htab->dynobj;
   BFD_ASSERT (dynobj != NULL);
 
-  if (htab->root.dynamic_sections_created)
+  if (htab->dynamic_sections_created)
     {
       /* Set the contents of the .interp section to the interpreter.  */
       if (bfd_link_executable (info) && !info->nointerp)
@@ -2060,8 +2046,8 @@ m32r_elf_size_dynamic_sections (bfd *out
       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
       locsymcount = symtab_hdr->sh_info;
       end_local_got = local_got + locsymcount;
-      s = htab->root.sgot;
-      srel = htab->root.srelgot;
+      s = htab->sgot;
+      srel = htab->srelgot;
       for (; local_got < end_local_got; ++local_got)
 	{
 	  if (*local_got > 0)
@@ -2078,7 +2064,7 @@ m32r_elf_size_dynamic_sections (bfd *out
 
   /* Allocate global sym .plt and .got entries, and space for global
      sym dynamic relocs.  */
-  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
+  elf_link_hash_traverse (htab, allocate_dynrelocs, info);
 
   /* We now have determined the sizes of the various dynamic sections.
      Allocate memory for them.  */
@@ -2088,9 +2074,9 @@ m32r_elf_size_dynamic_sections (bfd *out
       if ((s->flags & SEC_LINKER_CREATED) == 0)
 	continue;
 
-      if (s == htab->root.splt
-	  || s == htab->root.sgot
-	  || s == htab->root.sgotplt
+      if (s == htab->splt
+	  || s == htab->sgot
+	  || s == htab->sgotplt
 	  || s == htab->sdynbss)
 	{
 	  /* Strip this section if we don't need it; see the
@@ -2098,7 +2084,7 @@ m32r_elf_size_dynamic_sections (bfd *out
 	}
       else if (CONST_STRNEQ (bfd_section_name (s), ".rela"))
 	{
-	  if (s->size != 0 && s != htab->root.srelplt)
+	  if (s->size != 0 && s != htab->srelplt)
 	    relocs = TRUE;
 
 	  /* We use the reloc_count field as a counter if we need
@@ -2188,7 +2174,7 @@ m32r_elf_relocate_section (bfd *output_b
   Elf_Internal_Rela *rel, *relend;
   /* Assume success.  */
   bfd_boolean ret = TRUE;
-  struct elf_m32r_link_hash_table *htab = m32r_elf_hash_table (info);
+  struct elf_link_hash_table *htab = m32r_elf_hash_table (info);
   bfd_vma *local_got_offsets;
   asection *sgot, *splt, *sreloc;
   bfd_vma high_address = bfd_get_section_limit (input_bfd, input_section);
@@ -2198,8 +2184,8 @@ m32r_elf_relocate_section (bfd *output_b
 
   local_got_offsets = elf_local_got_offsets (input_bfd);
 
-  sgot = htab->root.sgot;
-  splt = htab->root.splt;
+  sgot = htab->sgot;
+  splt = htab->splt;
   sreloc = NULL;
 
   rel = relocs;
@@ -2295,7 +2281,7 @@ m32r_elf_relocate_section (bfd *output_b
 	      bfd_boolean dyn;
 	      sec = h->root.u.def.section;
 
-	      dyn = htab->root.dynamic_sections_created;
+	      dyn = htab->dynamic_sections_created;
 	      sec = h->root.u.def.section;
 	      if (r_type == R_M32R_GOTPC24
 		  || (r_type == R_M32R_GOTPC_HI_ULO
@@ -2516,7 +2502,7 @@ m32r_elf_relocate_section (bfd *output_b
 		  off = h->got.offset;
 		  BFD_ASSERT (off != (bfd_vma) -1);
 
-		  dyn = htab->root.dynamic_sections_created;
+		  dyn = htab->dynamic_sections_created;
 		  if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
 							 bfd_link_pic (info),
 							 h)
@@ -2576,7 +2562,7 @@ m32r_elf_relocate_section (bfd *output_b
 
 			  /* We need to generate a R_M32R_RELATIVE reloc
 			     for the dynamic linker.  */
-			  srelgot = htab->root.srelgot;
+			  srelgot = htab->srelgot;
 			  BFD_ASSERT (srelgot != NULL);
 
 			  outrel.r_offset = (sgot->output_section->vma
@@ -2892,7 +2878,7 @@ m32r_elf_finish_dynamic_symbol (bfd *out
 				struct elf_link_hash_entry *h,
 				Elf_Internal_Sym *sym)
 {
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   bfd_byte *loc;
 
 #ifdef DEBUG_PIC
@@ -2918,9 +2904,9 @@ m32r_elf_finish_dynamic_symbol (bfd *out
 
       BFD_ASSERT (h->dynindx != -1);
 
-      splt = htab->root.splt;
-      sgot = htab->root.sgotplt;
-      srela = htab->root.srelplt;
+      splt = htab->splt;
+      sgot = htab->sgotplt;
+      srela = htab->srelplt;
       BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
 
       /* Get the index in the procedure linkage table which
@@ -3014,8 +3000,8 @@ m32r_elf_finish_dynamic_symbol (bfd *out
       /* This symbol has an entry in the global offset table.  Set it
 	 up.  */
 
-      sgot = htab->root.sgot;
-      srela = htab->root.srelgot;
+      sgot = htab->sgot;
+      srela = htab->srelgot;
       BFD_ASSERT (sgot != NULL && srela != NULL);
 
       rela.r_offset = (sgot->output_section->vma
@@ -3063,7 +3049,7 @@ m32r_elf_finish_dynamic_symbol (bfd *out
 		  && (h->root.type == bfd_link_hash_defined
 		      || h->root.type == bfd_link_hash_defweak));
 
-      s = bfd_get_linker_section (htab->root.dynobj, ".rela.bss");
+      s = bfd_get_linker_section (htab->dynobj, ".rela.bss");
       BFD_ASSERT (s != NULL);
 
       rela.r_offset = (h->root.u.def.value
@@ -3078,7 +3064,7 @@ m32r_elf_finish_dynamic_symbol (bfd *out
     }
 
   /* Mark some specially defined symbols as absolute.  */
-  if (h == htab->root.hdynamic || h == htab->root.hgot)
+  if (h == htab->hdynamic || h == htab->hgot)
     sym->st_shndx = SHN_ABS;
 
   return TRUE;
@@ -3091,7 +3077,7 @@ static bfd_boolean
 m32r_elf_finish_dynamic_sections (bfd *output_bfd,
 				  struct bfd_link_info *info)
 {
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   bfd *dynobj;
   asection *sdyn;
   asection *sgot;
@@ -3104,12 +3090,12 @@ m32r_elf_finish_dynamic_sections (bfd *o
   if (htab == NULL)
     return FALSE;
 
-  dynobj = htab->root.dynobj;
+  dynobj = htab->dynobj;
 
-  sgot = htab->root.sgotplt;
+  sgot = htab->sgotplt;
   sdyn = bfd_get_linker_section (dynobj, ".dynamic");
 
-  if (htab->root.dynamic_sections_created)
+  if (htab->dynamic_sections_created)
     {
       asection *splt;
       Elf32_External_Dyn *dyncon, *dynconend;
@@ -3132,17 +3118,17 @@ m32r_elf_finish_dynamic_sections (bfd *o
 	      break;
 
 	    case DT_PLTGOT:
-	      s = htab->root.sgotplt;
+	      s = htab->sgotplt;
 	      goto get_vma;
 	    case DT_JMPREL:
-	      s = htab->root.srelplt;
+	      s = htab->srelplt;
 	    get_vma:
 	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
 	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
 	      break;
 
 	    case DT_PLTRELSZ:
-	      s = htab->root.srelplt;
+	      s = htab->srelplt;
 	      dyn.d_un.d_val = s->size;
 	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
 	      break;
@@ -3150,7 +3136,7 @@ m32r_elf_finish_dynamic_sections (bfd *o
 	}
 
       /* Fill in the first entry in the procedure linkage table.  */
-      splt = htab->root.splt;
+      splt = htab->splt;
       if (splt && splt->size > 0)
 	{
 	  if (bfd_link_pic (info))
@@ -3369,7 +3355,7 @@ m32r_elf_check_relocs (bfd *abfd,
   struct elf_link_hash_entry **sym_hashes;
   const Elf_Internal_Rela *rel;
   const Elf_Internal_Rela *rel_end;
-  struct elf_m32r_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   bfd *dynobj;
   asection *sreloc;
 
@@ -3384,7 +3370,7 @@ m32r_elf_check_relocs (bfd *abfd,
   if (htab == NULL)
     return FALSE;
 
-  dynobj = htab->root.dynobj;
+  dynobj = htab->dynobj;
 
   rel_end = relocs + sec->reloc_count;
   for (rel = relocs; rel < rel_end; rel++)
@@ -3406,7 +3392,7 @@ m32r_elf_check_relocs (bfd *abfd,
 	}
 
       /* Some relocs require a global offset table.  */
-      if (htab->root.sgot == NULL)
+      if (htab->sgot == NULL)
 	{
 	  switch (r_type)
 	    {
@@ -3423,7 +3409,7 @@ m32r_elf_check_relocs (bfd *abfd,
 	    case R_M32R_GOTPC_LO:
 	    case R_M32R_GOT24:
 	      if (dynobj == NULL)
-		htab->root.dynobj = dynobj = abfd;
+		htab->dynobj = dynobj = abfd;
 	      if (!_bfd_elf_create_got_section (dynobj, info))
 		return FALSE;
 	      break;
@@ -3540,7 +3526,7 @@ m32r_elf_check_relocs (bfd *abfd,
 	      struct elf_dyn_relocs **head;
 
 	      if (dynobj == NULL)
-		htab->root.dynobj = dynobj = abfd;
+		htab->dynobj = dynobj = abfd;
 
 	      /* When creating a shared object, we must copy these
 		 relocs into the output file.  We create a reloc
diff -rup binutils.orig/bfd/elf32-m68hc1x.h binutils-2.35/bfd/elf32-m68hc1x.h
--- binutils.orig/bfd/elf32-m68hc1x.h	2020-07-30 15:04:05.378466625 +0100
+++ binutils-2.35/bfd/elf32-m68hc1x.h	2020-07-30 15:04:16.710393941 +0100
@@ -120,9 +120,6 @@ struct m68hc11_elf_link_hash_table
   int top_index;
   asection **input_list;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   bfd_boolean (* size_one_stub)  (struct bfd_hash_entry*, void*);
   bfd_boolean (* build_one_stub) (struct bfd_hash_entry*, void*);
 };
diff -rup binutils.orig/bfd/elf32-m68k.c binutils-2.35/bfd/elf32-m68k.c
--- binutils.orig/bfd/elf32-m68k.c	2020-07-30 15:04:05.363466721 +0100
+++ binutils-2.35/bfd/elf32-m68k.c	2020-07-30 15:04:16.710393941 +0100
@@ -889,9 +889,6 @@ struct elf_m68k_link_hash_table
 {
   struct elf_link_hash_table root;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* The PLT format used by this link, or NULL if the format has not
      yet been chosen.  */
   const struct elf_m68k_plt_info *plt_info;
@@ -2836,7 +2833,7 @@ elf_m68k_check_relocs (bfd *abfd,
 		      void *vpp;
 		      Elf_Internal_Sym *isym;
 
-		      isym = bfd_sym_from_r_symndx (&elf_m68k_hash_table (info)->sym_cache,
+		      isym = bfd_sym_from_r_symndx (&elf_m68k_hash_table (info)->root.sym_cache,
 						    abfd, r_symndx);
 		      if (isym == NULL)
 			return FALSE;
diff -rup binutils.orig/bfd/elf32-metag.c binutils-2.35/bfd/elf32-metag.c
--- binutils.orig/bfd/elf32-metag.c	2020-07-30 15:04:05.379466619 +0100
+++ binutils-2.35/bfd/elf32-metag.c	2020-07-30 15:04:16.711393934 +0100
@@ -823,9 +823,6 @@ struct elf_metag_link_hash_table
   asection **input_list;
   Elf_Internal_Sym **all_local_syms;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* Data for LDM relocations.  */
   union
   {
@@ -2098,7 +2095,7 @@ elf_metag_check_relocs (bfd *abfd,
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->etab.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
diff -rup binutils.orig/bfd/elf32-microblaze.c binutils-2.35/bfd/elf32-microblaze.c
--- binutils.orig/bfd/elf32-microblaze.c	2020-07-30 15:04:05.367466696 +0100
+++ binutils-2.35/bfd/elf32-microblaze.c	2020-07-30 15:04:16.711393934 +0100
@@ -744,9 +744,6 @@ struct elf32_mb_link_hash_table
 {
   struct elf_link_hash_table elf;
 
-  /* Small local sym to section mapping cache.  */
-  struct sym_cache sym_sec;
-
   /* TLS Local Dynamic GOT Entry */
   union {
     bfd_signed_vma refcount;
@@ -2523,7 +2520,7 @@ microblaze_elf_check_relocs (bfd * abfd,
 		    Elf_Internal_Sym *isym;
 		    void *vpp;
 
-		    isym = bfd_sym_from_r_symndx (&htab->sym_sec,
+		    isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						  abfd, r_symndx);
 		    if (isym == NULL)
 		      return FALSE;
diff -rup binutils.orig/bfd/elf32-nds32.c binutils-2.35/bfd/elf32-nds32.c
--- binutils.orig/bfd/elf32-nds32.c	2020-07-30 15:04:05.365466709 +0100
+++ binutils-2.35/bfd/elf32-nds32.c	2020-07-30 15:04:16.712393928 +0100
@@ -3696,8 +3696,6 @@ nds32_elf_link_hash_table_create (bfd *a
       return NULL;
     }
 
-  ret->sdynbss = NULL;
-  ret->srelbss = NULL;
   ret->sym_ld_script = NULL;
 
   return &ret->root.root;
@@ -3833,7 +3831,7 @@ nds32_elf_create_dynamic_sections (bfd *
 	 initialize them at run time.  The linker script puts the .dynbss
 	 section into the .bss section of the final image.  */
       s = bfd_make_section (abfd, ".dynbss");
-      htab->sdynbss = s;
+      htab->root.sdynbss = s;
       if (s == NULL
 	  || !bfd_set_section_flags (s, SEC_ALLOC | SEC_LINKER_CREATED))
 	return FALSE;
@@ -3852,7 +3850,7 @@ nds32_elf_create_dynamic_sections (bfd *
 	{
 	  s = bfd_make_section (abfd, (bed->default_use_rela_p
 				       ? ".rela.bss" : ".rel.bss"));
-	  htab->srelbss = s;
+	  htab->root.srelbss = s;
 	  if (s == NULL
 	      || !bfd_set_section_flags (s, flags | SEC_READONLY)
 	      || !bfd_set_section_alignment (s, ptralign))
@@ -3988,7 +3986,7 @@ nds32_elf_adjust_dynamic_symbol (struct
      same memory location for the variable.  */
 
   htab = nds32_elf_hash_table (info);
-  s = htab->sdynbss;
+  s = htab->root.sdynbss;
   BFD_ASSERT (s != NULL);
 
   /* We must generate a R_NDS32_COPY reloc to tell the dynamic linker
@@ -3999,7 +3997,7 @@ nds32_elf_adjust_dynamic_symbol (struct
     {
       asection *srel;
 
-      srel = htab->srelbss;
+      srel = htab->root.srelbss;
       BFD_ASSERT (srel != NULL);
       srel->size += sizeof (Elf32_External_Rela);
       h->needs_copy = 1;
@@ -7277,7 +7275,8 @@ nds32_elf_check_relocs (bfd *abfd, struc
 		  void *vpp;
 
 		  Elf_Internal_Sym *isym;
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
+		  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
+						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
 
diff -rup binutils.orig/bfd/elf32-nds32.h binutils-2.35/bfd/elf32-nds32.h
--- binutils.orig/bfd/elf32-nds32.h	2020-07-30 15:04:05.378466625 +0100
+++ binutils-2.35/bfd/elf32-nds32.h	2020-07-30 15:04:16.712393928 +0100
@@ -122,13 +122,6 @@ struct elf_nds32_link_hash_table
 {
   struct elf_link_hash_table root;
 
-  /* Short-cuts to get to dynamic linker sections.  */
-  asection *sdynbss;
-  asection *srelbss;
-
-  /* Small local sym to section mapping cache.  */
-  struct sym_cache sym_cache;
-
   /* Target dependent options.  */
   int relax_fp_as_gp;		/* --mrelax-omit-fp.  */
   int eliminate_gc_relocs;	/* --meliminate-gc-relocs.  */
diff -rup binutils.orig/bfd/elf32-nios2.c binutils-2.35/bfd/elf32-nios2.c
--- binutils.orig/bfd/elf32-nios2.c	2020-07-30 15:04:05.375466645 +0100
+++ binutils-2.35/bfd/elf32-nios2.c	2020-07-30 15:04:16.712393928 +0100
@@ -1808,9 +1808,6 @@ struct elf32_nios2_link_hash_table
       bfd_vma offset;
     } tls_ldm_got;
 
-    /* Small local sym cache.  */
-    struct sym_cache sym_cache;
-
     bfd_vma res_n_size;
   };
 
@@ -4902,7 +4899,7 @@ nios2_elf32_check_relocs (bfd *abfd, str
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elf32-or1k.c binutils-2.35/bfd/elf32-or1k.c
--- binutils.orig/bfd/elf32-or1k.c	2020-07-30 15:04:05.371466670 +0100
+++ binutils-2.35/bfd/elf32-or1k.c	2020-07-30 15:04:16.713393921 +0100
@@ -916,9 +916,6 @@ struct elf_or1k_link_hash_table
 {
   struct elf_link_hash_table root;
 
-  /* Small local sym to section mapping cache.  */
-  struct sym_cache sym_sec;
-
   bfd_boolean saw_plta;
 };
 
@@ -2151,7 +2148,7 @@ or1k_elf_check_relocs (bfd *abfd,
 		    Elf_Internal_Sym *isym;
 		    void *vpp;
 
-		    isym = bfd_sym_from_r_symndx (&htab->sym_sec,
+		    isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
 						  abfd, r_symndx);
 		    if (isym == NULL)
 		      return FALSE;
diff -rup binutils.orig/bfd/elf32-ppc.c binutils-2.35/bfd/elf32-ppc.c
--- binutils.orig/bfd/elf32-ppc.c	2020-07-30 15:04:05.359466747 +0100
+++ binutils-2.35/bfd/elf32-ppc.c	2020-07-30 15:04:16.713393921 +0100
@@ -2212,9 +2212,6 @@ struct ppc_elf_link_hash_table
   int plt_slot_size;
   /* The size of the first PLT entry.  */
   int plt_initial_entry_size;
-
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
 };
 
 /* Rename some of the generic section flags to better document how they
@@ -2952,7 +2949,7 @@ ppc_elf_check_relocs (bfd *abfd,
       ifunc = NULL;
       if (h == NULL && htab->elf.target_os != is_vxworks)
 	{
-	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 							  abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
@@ -3335,7 +3332,7 @@ ppc_elf_check_relocs (bfd *abfd,
 	      asection *s;
 	      Elf_Internal_Sym *isym;
 
-	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					    abfd, r_symndx);
 	      if (isym == NULL)
 		return FALSE;
@@ -3495,7 +3492,7 @@ ppc_elf_check_relocs (bfd *abfd,
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elf32-s390.c binutils-2.35/bfd/elf32-s390.c
--- binutils.orig/bfd/elf32-s390.c	2020-07-30 15:04:05.376466638 +0100
+++ binutils-2.35/bfd/elf32-s390.c	2020-07-30 15:04:16.714393915 +0100
@@ -746,9 +746,6 @@ struct elf_s390_link_hash_table
     bfd_signed_vma refcount;
     bfd_vma offset;
   } tls_ldm_got;
-
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
 };
 
 /* Get the s390 ELF linker hash table from a link_info structure.  */
@@ -930,7 +927,7 @@ elf_s390_check_relocs (bfd *abfd,
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
@@ -1281,7 +1278,7 @@ elf_s390_check_relocs (bfd *abfd,
 		  asection *s;
 		  void *vpp;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
@@ -3722,7 +3719,7 @@ elf_s390_finish_dynamic_sections (bfd *o
 	    if (local_plt[i].plt.offset != (bfd_vma) -1)
 	      {
 		asection *sec = local_plt[i].sec;
-		isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, i);
+		isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, ibfd, i);
 		if (isym == NULL)
 		  return FALSE;
 
diff -rup binutils.orig/bfd/elf32-sh.c binutils-2.35/bfd/elf32-sh.c
--- binutils.orig/bfd/elf32-sh.c	2020-07-30 15:04:05.376466638 +0100
+++ binutils-2.35/bfd/elf32-sh.c	2020-07-30 15:04:16.714393915 +0100
@@ -2160,8 +2160,6 @@ struct elf_sh_link_hash_table
   struct elf_link_hash_table root;
 
   /* Short-cuts to get to dynamic linker sections.  */
-  asection *sdynbss;
-  asection *srelbss;
   asection *sfuncdesc;
   asection *srelfuncdesc;
   asection *srofixup;
@@ -2169,9 +2167,6 @@ struct elf_sh_link_hash_table
   /* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */
   asection *srelplt2;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* A counter or offset to track a TLS got entry.  */
   union
     {
@@ -2439,7 +2434,7 @@ sh_elf_create_dynamic_sections (bfd *abf
 	 section into the .bss section of the final image.  */
       s = bfd_make_section_anyway_with_flags (abfd, ".dynbss",
 					      SEC_ALLOC | SEC_LINKER_CREATED);
-      htab->sdynbss = s;
+      htab->root.sdynbss = s;
       if (s == NULL)
 	return FALSE;
 
@@ -2460,7 +2455,7 @@ sh_elf_create_dynamic_sections (bfd *abf
 						  (bed->default_use_rela_p
 						   ? ".rela.bss" : ".rel.bss"),
 						  flags | SEC_READONLY);
-	  htab->srelbss = s;
+	  htab->root.srelbss = s;
 	  if (s == NULL
 	      || !bfd_set_section_alignment (s, ptralign))
 	    return FALSE;
@@ -2580,7 +2575,7 @@ sh_elf_adjust_dynamic_symbol (struct bfd
      both the dynamic object and the regular object will refer to the
      same memory location for the variable.  */
 
-  s = htab->sdynbss;
+  s = htab->root.sdynbss;
   BFD_ASSERT (s != NULL);
 
   /* We must generate a R_SH_COPY reloc to tell the dynamic linker to
@@ -2591,7 +2586,7 @@ sh_elf_adjust_dynamic_symbol (struct bfd
     {
       asection *srel;
 
-      srel = htab->srelbss;
+      srel = htab->root.srelbss;
       BFD_ASSERT (srel != NULL);
       srel->size += sizeof (Elf32_External_Rela);
       h->needs_copy = 1;
@@ -3151,7 +3146,7 @@ sh_elf_size_dynamic_sections (bfd *outpu
 	  || s == htab->root.sgotplt
 	  || s == htab->sfuncdesc
 	  || s == htab->srofixup
-	  || s == htab->sdynbss)
+	  || s == htab->root.sdynbss)
 	{
 	  /* Strip this section if we don't need it; see the
 	     comment below.  */
@@ -5679,7 +5674,7 @@ sh_elf_check_relocs (bfd *abfd, struct b
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elf32-tic6x.c binutils-2.35/bfd/elf32-tic6x.c
--- binutils.orig/bfd/elf32-tic6x.c	2020-07-30 15:04:05.366466702 +0100
+++ binutils-2.35/bfd/elf32-tic6x.c	2020-07-30 15:04:16.714393915 +0100
@@ -46,9 +46,6 @@ struct elf32_tic6x_link_hash_table
   /* C6X specific command line arguments.  */
   struct elf32_tic6x_params params;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* The output BFD, for convenience.  */
   bfd *obfd;
 
@@ -2729,7 +2726,7 @@ elf32_tic6x_check_relocs (bfd *abfd, str
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
diff -rup binutils.orig/bfd/elf32-tilepro.c binutils-2.35/bfd/elf32-tilepro.c
--- binutils.orig/bfd/elf32-tilepro.c	2020-07-30 15:04:05.364466715 +0100
+++ binutils-2.35/bfd/elf32-tilepro.c	2020-07-30 15:04:16.715393908 +0100
@@ -727,19 +727,11 @@ tilepro_elf_mkobject (bfd *abfd)
 #include "elf/common.h"
 #include "elf/internal.h"
 
-struct tilepro_elf_link_hash_table
-{
-  struct elf_link_hash_table elf;
-
-  /* Small local sym to section mapping cache.  */
-  struct sym_cache sym_cache;
-};
-
 /* Get the Tilepro ELF linker hash table from a link_info structure.  */
 #define tilepro_elf_hash_table(p) \
   (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
   == TILEPRO_ELF_DATA \
-  ? ((struct tilepro_elf_link_hash_table *) ((p)->hash)) : NULL)
+  ? ((struct elf_link_hash_table *) ((p)->hash)) : NULL)
 
 static reloc_howto_type *
 tilepro_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
@@ -1184,14 +1176,14 @@ link_hash_newfunc (struct bfd_hash_entry
 static struct bfd_link_hash_table *
 tilepro_elf_link_hash_table_create (bfd *abfd)
 {
-  struct tilepro_elf_link_hash_table *ret;
-  size_t amt = sizeof (struct tilepro_elf_link_hash_table);
+  struct elf_link_hash_table *ret;
+  size_t amt = sizeof (struct elf_link_hash_table);
 
-  ret = (struct tilepro_elf_link_hash_table *) bfd_zmalloc (amt);
+  ret = (struct elf_link_hash_table *) bfd_zmalloc (amt);
   if (ret == NULL)
     return NULL;
 
-  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
+  if (!_bfd_elf_link_hash_table_init (ret, abfd, link_hash_newfunc,
 				      sizeof (struct tilepro_elf_link_hash_entry),
 				      TILEPRO_ELF_DATA))
     {
@@ -1199,7 +1191,7 @@ tilepro_elf_link_hash_table_create (bfd
       return NULL;
     }
 
-  return &ret->elf.root;
+  return &ret->root;
 }
 
 /* Create the .got section.  */
@@ -1402,7 +1394,7 @@ static bfd_boolean
 tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
 			  asection *sec, const Elf_Internal_Rela *relocs)
 {
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   Elf_Internal_Shdr *symtab_hdr;
   struct elf_link_hash_entry **sym_hashes;
   const Elf_Internal_Rela *rel;
@@ -1423,8 +1415,8 @@ tilepro_elf_check_relocs (bfd *abfd, str
 
   BFD_ASSERT (is_tilepro_elf (abfd) || num_relocs == 0);
 
-  if (htab->elf.dynobj == NULL)
-    htab->elf.dynobj = abfd;
+  if (htab->dynobj == NULL)
+    htab->dynobj = abfd;
 
   rel_end = relocs + num_relocs;
   for (rel = relocs; rel < rel_end; rel++)
@@ -1569,9 +1561,9 @@ tilepro_elf_check_relocs (bfd *abfd, str
 	      }
 	  }
 
-	  if (htab->elf.sgot == NULL)
+	  if (htab->sgot == NULL)
 	    {
-	      if (!tilepro_elf_create_got_section (htab->elf.dynobj, info))
+	      if (!tilepro_elf_create_got_section (htab->dynobj, info))
 		return FALSE;
 	    }
 	  break;
@@ -1716,7 +1708,7 @@ tilepro_elf_check_relocs (bfd *abfd, str
 	      if (sreloc == NULL)
 		{
 		  sreloc = _bfd_elf_make_dynamic_reloc_section
-		    (sec, htab->elf.dynobj, 2, abfd, /*rela?*/ TRUE);
+		    (sec, htab->dynobj, 2, abfd, /*rela?*/ TRUE);
 
 		  if (sreloc == NULL)
 		    return FALSE;
@@ -1754,7 +1746,7 @@ tilepro_elf_check_relocs (bfd *abfd, str
 		{
 		  size_t amt = sizeof *p;
 		  p = ((struct elf_dyn_relocs *)
-		       bfd_alloc (htab->elf.dynobj, amt));
+		       bfd_alloc (htab->dynobj, amt));
 		  if (p == NULL)
 		    return FALSE;
 		  p->next = *head;
@@ -1850,14 +1842,14 @@ static bfd_boolean
 tilepro_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
 				   struct elf_link_hash_entry *h)
 {
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   asection *s, *srel;
 
   htab = tilepro_elf_hash_table (info);
   BFD_ASSERT (htab != NULL);
 
   /* Make sure we know what is going on here.  */
-  BFD_ASSERT (htab->elf.dynobj != NULL
+  BFD_ASSERT (htab->dynobj != NULL
 	      && (h->needs_plt
 		  || h->is_weakalias
 		  || (h->def_dynamic
@@ -1947,13 +1939,13 @@ tilepro_elf_adjust_dynamic_symbol (struc
      .rel.bss section we are going to use.  */
   if ((h->root.u.def.section->flags & SEC_READONLY) != 0)
     {
-      s = htab->elf.sdynrelro;
-      srel = htab->elf.sreldynrelro;
+      s = htab->sdynrelro;
+      srel = htab->sreldynrelro;
     }
   else
     {
-      s = htab->elf.sdynbss;
-      srel = htab->elf.srelbss;
+      s = htab->sdynbss;
+      srel = htab->srelbss;
     }
   if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
     {
@@ -1971,7 +1963,7 @@ static bfd_boolean
 allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
 {
   struct bfd_link_info *info;
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   struct elf_dyn_relocs *p;
 
   if (h->root.type == bfd_link_hash_indirect)
@@ -1981,7 +1973,7 @@ allocate_dynrelocs (struct elf_link_hash
   htab = tilepro_elf_hash_table (info);
   BFD_ASSERT (htab != NULL);
 
-  if (htab->elf.dynamic_sections_created
+  if (htab->dynamic_sections_created
       && h->plt.refcount > 0)
     {
       /* Make sure this symbol is output as a dynamic symbol.
@@ -1995,7 +1987,7 @@ allocate_dynrelocs (struct elf_link_hash
 
       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))
 	{
-	  asection *s = htab->elf.splt;
+	  asection *s = htab->splt;
 
 	  /* Allocate room for the header.  */
 	  if (s->size == 0)
@@ -2021,10 +2013,10 @@ allocate_dynrelocs (struct elf_link_hash
 	  s->size += PLT_ENTRY_SIZE;
 
 	  /* We also need to make an entry in the .got.plt section.  */
-	  htab->elf.sgotplt->size += GOT_ENTRY_SIZE;
+	  htab->sgotplt->size += GOT_ENTRY_SIZE;
 
 	  /* We also need to make an entry in the .rela.plt section.  */
-	  htab->elf.srelplt->size += TILEPRO_ELF_RELA_BYTES;
+	  htab->srelplt->size += TILEPRO_ELF_RELA_BYTES;
 	}
       else
 	{
@@ -2060,22 +2052,22 @@ allocate_dynrelocs (struct elf_link_hash
 	    return FALSE;
 	}
 
-      s = htab->elf.sgot;
+      s = htab->sgot;
       h->got.offset = s->size;
       s->size += TILEPRO_BYTES_PER_WORD;
       /* R_TILEPRO_IMM16_Xn_TLS_GD entries need 2 consecutive GOT slots. */
       if (tls_type == GOT_TLS_GD)
 	s->size += TILEPRO_BYTES_PER_WORD;
-      dyn = htab->elf.dynamic_sections_created;
+      dyn = htab->dynamic_sections_created;
       /* R_TILEPRO_IMM16_Xn_TLS_IE_xxx needs one dynamic relocation,
 	 R_TILEPRO_IMM16_Xn_TLS_GD_xxx needs two if local symbol and two if
 	 global.  */
       if (tls_type == GOT_TLS_GD || tls_type == GOT_TLS_IE)
-	htab->elf.srelgot->size += 2 * TILEPRO_ELF_RELA_BYTES;
+	htab->srelgot->size += 2 * TILEPRO_ELF_RELA_BYTES;
       else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
 						bfd_link_pic (info),
 						h))
-	htab->elf.srelgot->size += TILEPRO_ELF_RELA_BYTES;
+	htab->srelgot->size += TILEPRO_ELF_RELA_BYTES;
     }
   else
     h->got.offset = (bfd_vma) -1;
@@ -2134,7 +2126,7 @@ allocate_dynrelocs (struct elf_link_hash
       if (!h->non_got_ref
 	  && ((h->def_dynamic
 	       && !h->def_regular)
-	      || (htab->elf.dynamic_sections_created
+	      || (htab->dynamic_sections_created
 		  && (h->root.type == bfd_link_hash_undefweak
 		      || h->root.type == bfd_link_hash_undefined))))
 	{
@@ -2195,14 +2187,14 @@ tilepro_elf_size_dynamic_sections (bfd *
 {
   (void)output_bfd;
 
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   bfd *dynobj;
   asection *s;
   bfd *ibfd;
 
   htab = tilepro_elf_hash_table (info);
   BFD_ASSERT (htab != NULL);
-  dynobj = htab->elf.dynobj;
+  dynobj = htab->dynobj;
   BFD_ASSERT (dynobj != NULL);
 
   if (elf_hash_table (info)->dynamic_sections_created)
@@ -2268,8 +2260,8 @@ tilepro_elf_size_dynamic_sections (bfd *
       locsymcount = symtab_hdr->sh_info;
       end_local_got = local_got + locsymcount;
       local_tls_type = _bfd_tilepro_elf_local_got_tls_type (ibfd);
-      s = htab->elf.sgot;
-      srel = htab->elf.srelgot;
+      s = htab->sgot;
+      srel = htab->srelgot;
       for (; local_got < end_local_got; ++local_got, ++local_tls_type)
 	{
 	  if (*local_got > 0)
@@ -2290,19 +2282,19 @@ tilepro_elf_size_dynamic_sections (bfd *
 
   /* Allocate global sym .plt and .got entries, and space for global
      sym dynamic relocs.  */
-  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
+  elf_link_hash_traverse (htab, allocate_dynrelocs, info);
 
   if (elf_hash_table (info)->dynamic_sections_created)
     {
       /* If the .got section is more than 0x8000 bytes, we add
 	 0x8000 to the value of _GLOBAL_OFFSET_TABLE_, so that 16
 	 bit relocations have a greater chance of working. */
-      if (htab->elf.sgot->size >= 0x8000
+      if (htab->sgot->size >= 0x8000
 	  && elf_hash_table (info)->hgot->root.u.def.value == 0)
 	elf_hash_table (info)->hgot->root.u.def.value = 0x8000;
     }
 
-  if (htab->elf.sgotplt)
+  if (htab->sgotplt)
     {
       struct elf_link_hash_entry *got;
       got = elf_link_hash_lookup (elf_hash_table (info),
@@ -2313,14 +2305,14 @@ tilepro_elf_size_dynamic_sections (bfd *
 	 entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.  */
       if ((got == NULL
 	   || !got->ref_regular_nonweak)
-	  && (htab->elf.sgotplt->size
+	  && (htab->sgotplt->size
 	      == GOTPLT_HEADER_SIZE)
-	  && (htab->elf.splt == NULL
-	      || htab->elf.splt->size == 0)
-	  && (htab->elf.sgot == NULL
-	      || (htab->elf.sgot->size
+	  && (htab->splt == NULL
+	      || htab->splt->size == 0)
+	  && (htab->sgot == NULL
+	      || (htab->sgot->size
 		  == get_elf_backend_data (output_bfd)->got_header_size)))
-	htab->elf.sgotplt->size = 0;
+	htab->sgotplt->size = 0;
     }
 
   /* The check_relocs and adjust_dynamic_symbol entry points have
@@ -2331,11 +2323,11 @@ tilepro_elf_size_dynamic_sections (bfd *
       if ((s->flags & SEC_LINKER_CREATED) == 0)
 	continue;
 
-      if (s == htab->elf.splt
-	  || s == htab->elf.sgot
-	  || s == htab->elf.sgotplt
-	  || s == htab->elf.sdynbss
-	  || s == htab->elf.sdynrelro)
+      if (s == htab->splt
+	  || s == htab->sgot
+	  || s == htab->sgotplt
+	  || s == htab->sdynbss
+	  || s == htab->sdynrelro)
 	{
 	  /* Strip this section if we don't need it; see the
 	     comment below.  */
@@ -2527,7 +2519,7 @@ tilepro_elf_relocate_section (bfd *outpu
 			      Elf_Internal_Sym *local_syms,
 			      asection **local_sections)
 {
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
   Elf_Internal_Shdr *symtab_hdr;
   struct elf_link_hash_entry **sym_hashes;
   bfd_vma *local_got_offsets;
@@ -2758,7 +2750,7 @@ tilepro_elf_relocate_section (bfd *outpu
 	case R_TILEPRO_IMM16_X1_GOT_HA:
 	  /* Relocation is to the entry for this symbol in the global
 	     offset table.  */
-	  if (htab->elf.sgot == NULL)
+	  if (htab->sgot == NULL)
 	    abort ();
 
 	  if (h != NULL)
@@ -2792,7 +2784,7 @@ tilepro_elf_relocate_section (bfd *outpu
 		  else
 		    {
 		      bfd_put_32 (output_bfd, relocation,
-					  htab->elf.sgot->contents + off);
+					  htab->sgot->contents + off);
 		      h->got.offset |= 1;
 		    }
 		}
@@ -2820,11 +2812,11 @@ tilepro_elf_relocate_section (bfd *outpu
 
 		      /* We need to generate a R_TILEPRO_RELATIVE reloc
 			 for the dynamic linker.  */
-		      s = htab->elf.srelgot;
+		      s = htab->srelgot;
 		      BFD_ASSERT (s != NULL);
 
-		      outrel.r_offset = (htab->elf.sgot->output_section->vma
-					 + htab->elf.sgot->output_offset
+		      outrel.r_offset = (htab->sgot->output_section->vma
+					 + htab->sgot->output_offset
 					 + off);
 		      outrel.r_info = ELF32_R_INFO (0, R_TILEPRO_RELATIVE);
 		      outrel.r_addend = relocation;
@@ -2833,7 +2825,7 @@ tilepro_elf_relocate_section (bfd *outpu
 		    }
 
 		  bfd_put_32 (output_bfd, relocation,
-				      htab->elf.sgot->contents + off);
+				      htab->sgot->contents + off);
 		  local_got_offsets[r_symndx] |= 1;
 		}
 	    }
@@ -2845,7 +2837,7 @@ tilepro_elf_relocate_section (bfd *outpu
 	     procedure linkage table.  */
 	  BFD_ASSERT (h != NULL);
 
-	  if (h->plt.offset == (bfd_vma) -1 || htab->elf.splt == NULL)
+	  if (h->plt.offset == (bfd_vma) -1 || htab->splt == NULL)
 	    {
 	      /* We didn't make a PLT entry for this symbol.  This
 		 happens when statically linking PIC code, or when
@@ -2853,8 +2845,8 @@ tilepro_elf_relocate_section (bfd *outpu
 	      break;
 	    }
 
-	  relocation = (htab->elf.splt->output_section->vma
-			+ htab->elf.splt->output_offset
+	  relocation = (htab->splt->output_section->vma
+			+ htab->splt->output_offset
 			+ h->plt.offset);
 	  unresolved_reloc = FALSE;
 	  break;
@@ -2993,7 +2985,7 @@ tilepro_elf_relocate_section (bfd *outpu
 		      outrel.r_addend = relocation + rel->r_addend;
 
 		      if (is_plt)
-			sec = htab->elf.splt;
+			sec = htab->splt;
 
 		      if (bfd_is_abs_section (sec))
 			indx = 0;
@@ -3016,7 +3008,7 @@ tilepro_elf_relocate_section (bfd *outpu
 
 			  if (indx == 0)
 			    {
-			      osec = htab->elf.text_index_section;
+			      osec = htab->text_index_section;
 			      indx = elf_section_data (osec)->dynindx;
 			    }
 
@@ -3142,7 +3134,7 @@ tilepro_elf_relocate_section (bfd *outpu
 	      local_got_offsets[r_symndx] |= 1;
 	    }
 
-	  if (htab->elf.sgot == NULL)
+	  if (htab->sgot == NULL)
 	    abort ();
 
 	  if ((off & 1) != 0)
@@ -3153,13 +3145,13 @@ tilepro_elf_relocate_section (bfd *outpu
 	      int indx = 0;
 	      bfd_boolean need_relocs = FALSE;
 
-	      if (htab->elf.srelgot == NULL)
+	      if (htab->srelgot == NULL)
 		abort ();
 
 	      if (h != NULL)
 	      {
 		bfd_boolean dyn;
-		dyn = htab->elf.dynamic_sections_created;
+		dyn = htab->dynamic_sections_created;
 
 		if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn,
 						     bfd_link_pic (info),
@@ -3190,18 +3182,18 @@ tilepro_elf_relocate_section (bfd *outpu
 		  case R_TILEPRO_IMM16_X0_TLS_IE_HA:
 		  case R_TILEPRO_IMM16_X1_TLS_IE_HA:
 		    if (need_relocs) {
-		      bfd_put_32 (output_bfd, 0, htab->elf.sgot->contents + off);
-		      outrel.r_offset = (htab->elf.sgot->output_section->vma
-				       + htab->elf.sgot->output_offset + off);
+		      bfd_put_32 (output_bfd, 0, htab->sgot->contents + off);
+		      outrel.r_offset = (htab->sgot->output_section->vma
+				       + htab->sgot->output_offset + off);
 		      outrel.r_addend = 0;
 		      if (indx == 0)
 			outrel.r_addend = relocation - dtpoff_base (info);
 		      outrel.r_info = ELF32_R_INFO (indx, R_TILEPRO_TLS_TPOFF32);
-		      tilepro_elf_append_rela_32 (output_bfd, htab->elf.srelgot,
+		      tilepro_elf_append_rela_32 (output_bfd, htab->srelgot,
 						  &outrel);
 		    } else {
 		      bfd_put_32 (output_bfd, tpoff (info, relocation),
-				  htab->elf.sgot->contents + off);
+				  htab->sgot->contents + off);
 		    }
 		    break;
 
@@ -3214,31 +3206,31 @@ tilepro_elf_relocate_section (bfd *outpu
 		  case R_TILEPRO_IMM16_X0_TLS_GD_HA:
 		  case R_TILEPRO_IMM16_X1_TLS_GD_HA:
 		    if (need_relocs) {
-		      outrel.r_offset = (htab->elf.sgot->output_section->vma
-				       + htab->elf.sgot->output_offset + off);
+		      outrel.r_offset = (htab->sgot->output_section->vma
+				       + htab->sgot->output_offset + off);
 		      outrel.r_addend = 0;
 		      outrel.r_info = ELF32_R_INFO (indx, R_TILEPRO_TLS_DTPMOD32);
-		      bfd_put_32 (output_bfd, 0, htab->elf.sgot->contents + off);
-		      tilepro_elf_append_rela_32 (output_bfd, htab->elf.srelgot,
+		      bfd_put_32 (output_bfd, 0, htab->sgot->contents + off);
+		      tilepro_elf_append_rela_32 (output_bfd, htab->srelgot,
 						  &outrel);
 		      if (indx == 0)
 			{
 			  BFD_ASSERT (! unresolved_reloc);
 			  bfd_put_32 (output_bfd,
 				      relocation - dtpoff_base (info),
-				      (htab->elf.sgot->contents + off +
+				      (htab->sgot->contents + off +
 				       TILEPRO_BYTES_PER_WORD));
 			}
 		      else
 			{
 			  bfd_put_32 (output_bfd, 0,
-				      (htab->elf.sgot->contents + off +
+				      (htab->sgot->contents + off +
 				       TILEPRO_BYTES_PER_WORD));
 			  outrel.r_info = ELF32_R_INFO (indx,
 							R_TILEPRO_TLS_DTPOFF32);
 			  outrel.r_offset += TILEPRO_BYTES_PER_WORD;
 			  tilepro_elf_append_rela_32 (output_bfd,
-						      htab->elf.srelgot, &outrel);
+						      htab->srelgot, &outrel);
 			}
 		    }
 
@@ -3249,9 +3241,9 @@ tilepro_elf_relocate_section (bfd *outpu
 			 symbol binding locally.  Mark it as belonging
 			 to module 1, the executable.  */
 		      bfd_put_32 (output_bfd, 1,
-				  htab->elf.sgot->contents + off );
+				  htab->sgot->contents + off );
 		      bfd_put_32 (output_bfd, relocation - dtpoff_base (info),
-				  htab->elf.sgot->contents + off +
+				  htab->sgot->contents + off +
 				  TILEPRO_BYTES_PER_WORD);
 		   }
 		   break;
@@ -3411,7 +3403,7 @@ tilepro_elf_finish_dynamic_symbol (bfd *
 				   struct elf_link_hash_entry *h,
 				   Elf_Internal_Sym *sym)
 {
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
 
   htab = tilepro_elf_hash_table (info);
   BFD_ASSERT (htab != NULL);
@@ -3431,9 +3423,9 @@ tilepro_elf_finish_dynamic_symbol (bfd *
 
       BFD_ASSERT (h->dynindx != -1);
 
-      splt = htab->elf.splt;
-      srela = htab->elf.srelplt;
-      sgotplt = htab->elf.sgotplt;
+      splt = htab->splt;
+      srela = htab->srelplt;
+      sgotplt = htab->sgotplt;
 
       if (splt == NULL || srela == NULL)
        abort ();
@@ -3481,8 +3473,8 @@ tilepro_elf_finish_dynamic_symbol (bfd *
 
       /* This symbol has an entry in the GOT.  Set it up.  */
 
-      sgot = htab->elf.sgot;
-      srela = htab->elf.srelgot;
+      sgot = htab->sgot;
+      srela = htab->srelgot;
       BFD_ASSERT (sgot != NULL && srela != NULL);
 
       rela.r_offset = (sgot->output_section->vma
@@ -3528,16 +3520,16 @@ tilepro_elf_finish_dynamic_symbol (bfd *
 		       + h->root.u.def.section->output_offset);
       rela.r_info = ELF32_R_INFO (h->dynindx, R_TILEPRO_COPY);
       rela.r_addend = 0;
-      if (h->root.u.def.section == htab->elf.sdynrelro)
-	s = htab->elf.sreldynrelro;
+      if (h->root.u.def.section == htab->sdynrelro)
+	s = htab->sreldynrelro;
       else
-	s = htab->elf.srelbss;
+	s = htab->srelbss;
       tilepro_elf_append_rela_32 (output_bfd, s, &rela);
     }
 
   /* Mark some specially defined symbols as absolute. */
-  if (h == htab->elf.hdynamic
-      || (h == htab->elf.hgot || h == htab->elf.hplt))
+  if (h == htab->hdynamic
+      || (h == htab->hgot || h == htab->hplt))
     sym->st_shndx = SHN_ABS;
 
   return TRUE;
@@ -3551,7 +3543,7 @@ tilepro_finish_dyn (bfd *output_bfd, str
 		    asection *splt ATTRIBUTE_UNUSED)
 {
   Elf32_External_Dyn *dyncon, *dynconend;
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
 
   htab = tilepro_elf_hash_table (info);
   BFD_ASSERT (htab != NULL);
@@ -3567,15 +3559,15 @@ tilepro_finish_dyn (bfd *output_bfd, str
       switch (dyn.d_tag)
 	{
 	case DT_PLTGOT:
-	  s = htab->elf.sgotplt;
+	  s = htab->sgotplt;
 	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
 	  break;
 	case DT_JMPREL:
-	  s = htab->elf.srelplt;
+	  s = htab->srelplt;
 	  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
 	  break;
 	case DT_PLTRELSZ:
-	  s = htab->elf.srelplt;
+	  s = htab->srelplt;
 	  dyn.d_un.d_val = s->size;
 	  break;
 	default:
@@ -3593,11 +3585,11 @@ tilepro_elf_finish_dynamic_sections (bfd
 {
   bfd *dynobj;
   asection *sdyn;
-  struct tilepro_elf_link_hash_table *htab;
+  struct elf_link_hash_table *htab;
 
   htab = tilepro_elf_hash_table (info);
   BFD_ASSERT (htab != NULL);
-  dynobj = htab->elf.dynobj;
+  dynobj = htab->dynobj;
 
   sdyn = bfd_get_linker_section (dynobj, ".dynamic");
 
@@ -3606,7 +3598,7 @@ tilepro_elf_finish_dynamic_sections (bfd
       asection *splt;
       bfd_boolean ret;
 
-      splt = htab->elf.splt;
+      splt = htab->splt;
       BFD_ASSERT (splt != NULL && sdyn != NULL);
 
       ret = tilepro_finish_dyn (output_bfd, info, dynobj, sdyn, splt);
@@ -3627,42 +3619,42 @@ tilepro_elf_finish_dynamic_sections (bfd
 	  = PLT_ENTRY_SIZE;
     }
 
-  if (htab->elf.sgotplt)
+  if (htab->sgotplt)
     {
-      if (bfd_is_abs_section (htab->elf.sgotplt->output_section))
+      if (bfd_is_abs_section (htab->sgotplt->output_section))
 	{
 	  _bfd_error_handler
-	    (_("discarded output section: `%pA'"), htab->elf.sgotplt);
+	    (_("discarded output section: `%pA'"), htab->sgotplt);
 	  return FALSE;
 	}
 
-      if (htab->elf.sgotplt->size > 0)
+      if (htab->sgotplt->size > 0)
 	{
 	  /* Write the first two entries in .got.plt, needed for the dynamic
 	     linker.  */
 	  bfd_put_32 (output_bfd, (bfd_vma) -1,
-		      htab->elf.sgotplt->contents);
+		      htab->sgotplt->contents);
 	  bfd_put_32 (output_bfd, (bfd_vma) 0,
-		      htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
+		      htab->sgotplt->contents + GOT_ENTRY_SIZE);
 	}
 
-      elf_section_data (htab->elf.sgotplt->output_section)->this_hdr.sh_entsize
+      elf_section_data (htab->sgotplt->output_section)->this_hdr.sh_entsize
 	= GOT_ENTRY_SIZE;
     }
 
-  if (htab->elf.sgot)
+  if (htab->sgot)
     {
-      if (htab->elf.sgot->size > 0)
+      if (htab->sgot->size > 0)
 	{
 	  /* Set the first entry in the global offset table to the address of
 	     the dynamic section.  */
 	  bfd_vma val = (sdyn ?
 			 sdyn->output_section->vma + sdyn->output_offset :
 			 0);
-	  bfd_put_32 (output_bfd, val, htab->elf.sgot->contents);
+	  bfd_put_32 (output_bfd, val, htab->sgot->contents);
 	}
 
-      elf_section_data (htab->elf.sgot->output_section)->this_hdr.sh_entsize
+      elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize
 	= GOT_ENTRY_SIZE;
     }
 
diff -rup binutils.orig/bfd/elf64-ppc.c binutils-2.35/bfd/elf64-ppc.c
--- binutils.orig/bfd/elf64-ppc.c	2020-07-30 15:04:05.363466721 +0100
+++ binutils-2.35/bfd/elf64-ppc.c	2020-07-30 15:04:16.716393902 +0100
@@ -3250,9 +3250,6 @@ struct ppc_link_hash_table
 
   /* Incremented every time we size stubs.  */
   unsigned int stub_iteration;
-
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
 };
 
 /* Rename some of the generic section flags to better document how they
@@ -4383,7 +4380,8 @@ ppc64_elf_before_check_relocs (bfd *ibfd
 	      Elf_Internal_Sym *isym;
 	      asection *s;
 
-	      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, r_symndx);
+	      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, ibfd,
+					    r_symndx);
 	      if (isym == NULL)
 		{
 		  if (elf_section_data (opd)->relocs != relocs)
@@ -4684,7 +4682,7 @@ ppc64_elf_check_relocs (bfd *abfd, struc
 	}
       else
 	{
-	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 							  abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
@@ -4955,7 +4953,7 @@ ppc64_elf_check_relocs (bfd *abfd, struc
 	      {
 		Elf_Internal_Sym *isym;
 
-		isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					      abfd, r_symndx);
 		if (isym == NULL)
 		  return FALSE;
@@ -5231,7 +5229,7 @@ ppc64_elf_check_relocs (bfd *abfd, struc
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elf64-s390.c binutils-2.35/bfd/elf64-s390.c
--- binutils.orig/bfd/elf64-s390.c	2020-07-30 15:04:05.369466683 +0100
+++ binutils-2.35/bfd/elf64-s390.c	2020-07-30 15:04:16.716393902 +0100
@@ -663,9 +663,6 @@ struct elf_s390_link_hash_table
     bfd_vma offset;
   } tls_ldm_got;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* Options passed from the linker.  */
   struct s390_elf_params *params;
 };
@@ -852,7 +849,7 @@ elf_s390_check_relocs (bfd *abfd,
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
@@ -1216,7 +1213,7 @@ elf_s390_check_relocs (bfd *abfd,
 		  asection *s;
 		  void *vpp;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
@@ -2258,7 +2255,7 @@ elf_s390_relocate_section (bfd *output_b
 				  & 0xff00f000) == 0xe300c000
 			      && bfd_get_8 (input_bfd,
 					    contents + rel->r_offset + 3) == 0x04))
-		      && (isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		      && (isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 							input_bfd, r_symndx))
 		      && isym->st_shndx != SHN_ABS
 		      && h != htab->elf.hdynamic
@@ -3572,7 +3569,7 @@ elf_s390_finish_dynamic_sections (bfd *o
 	    if (local_plt[i].plt.offset != (bfd_vma) -1)
 	      {
 		asection *sec = local_plt[i].sec;
-		isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, i);
+		isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, ibfd, i);
 		if (isym == NULL)
 		  return FALSE;
 
diff -rup binutils.orig/bfd/elf64-x86-64.c binutils-2.35/bfd/elf64-x86-64.c
--- binutils.orig/bfd/elf64-x86-64.c	2020-07-30 15:04:05.365466709 +0100
+++ binutils-2.35/bfd/elf64-x86-64.c	2020-07-30 15:04:16.717393895 +0100
@@ -1371,7 +1371,7 @@ elf_x86_64_tls_transition (struct bfd_li
 	    {
 	      Elf_Internal_Sym *isym;
 
-	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	      isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					    abfd, r_symndx);
 	      name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
 	    }
@@ -1559,7 +1559,7 @@ elf_x86_64_convert_load_reloc (bfd *abfd
   if (h == NULL)
     {
       Elf_Internal_Sym *isym
-	= bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
+	= bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd, r_symndx);
 
       /* Skip relocation against undefined symbols.  */
       if (isym->st_shndx == SHN_UNDEF)
@@ -1907,7 +1907,7 @@ elf_x86_64_check_relocs (bfd *abfd, stru
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    goto error_return;
@@ -2308,7 +2308,7 @@ elf_x86_64_check_relocs (bfd *abfd, stru
 		  asection *s;
 		  void **vpp;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    goto error_return;
diff -rup binutils.orig/bfd/elfnn-aarch64.c binutils-2.35/bfd/elfnn-aarch64.c
--- binutils.orig/bfd/elfnn-aarch64.c	2020-07-30 15:04:05.371466670 +0100
+++ binutils-2.35/bfd/elfnn-aarch64.c	2020-07-30 15:04:16.717393895 +0100
@@ -2643,9 +2643,6 @@ struct elf_aarch64_link_hash_table
   /* The bytes of the subsequent PLT entry.  */
   const bfd_byte *plt_entry;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* For convenience in allocate_dynrelocs.  */
   bfd *obfd;
 
@@ -7611,7 +7608,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, s
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+	  isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
 					abfd, r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
@@ -7838,7 +7835,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, s
 		asection *s;
 		void **vpp;
 
-		isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		isym = bfd_sym_from_r_symndx (&htab->root.sym_cache,
 					      abfd, r_symndx);
 		if (isym == NULL)
 		  return FALSE;
Only in binutils-2.35/bfd: elfnn-aarch64.c.orig
diff -rup binutils.orig/bfd/elfnn-riscv.c binutils-2.35/bfd/elfnn-riscv.c
--- binutils.orig/bfd/elfnn-riscv.c	2020-07-30 15:04:05.365466709 +0100
+++ binutils-2.35/bfd/elfnn-riscv.c	2020-07-30 15:04:16.718393889 +0100
@@ -113,9 +113,6 @@ struct riscv_elf_link_hash_table
   /* Short-cuts to get to dynamic linker sections.  */
   asection *sdyntdata;
 
-  /* Small local sym to section mapping cache.  */
-  struct sym_cache sym_cache;
-
   /* The max alignment of output sections.  */
   bfd_vma max_alignment;
 };
@@ -681,7 +678,7 @@ riscv_elf_check_relocs (bfd *abfd, struc
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elfxx-mips.c binutils-2.35/bfd/elfxx-mips.c
--- binutils.orig/bfd/elfxx-mips.c	2020-07-30 15:04:05.376466638 +0100
+++ binutils-2.35/bfd/elfxx-mips.c	2020-07-30 15:04:16.719393882 +0100
@@ -527,9 +527,6 @@ struct mips_elf_link_hash_table
      returns null.  */
   asection *(*add_stub_section) (const char *, asection *, asection *);
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* Is the PLT header compressed?  */
   unsigned int plt_header_is_comp : 1;
 };
@@ -4401,7 +4398,7 @@ mips_elf_resolve_got_page_ref (void **re
       Elf_Internal_Sym *isym;
 
       /* Read in the symbol.  */
-      isym = bfd_sym_from_r_symndx (&htab->sym_cache, ref->u.abfd,
+      isym = bfd_sym_from_r_symndx (&htab->root.sym_cache, ref->u.abfd,
 				    ref->symndx);
       if (isym == NULL)
 	{
diff -rup binutils.orig/bfd/elfxx-sparc.c binutils-2.35/bfd/elfxx-sparc.c
--- binutils.orig/bfd/elfxx-sparc.c	2020-07-30 15:04:05.360466741 +0100
+++ binutils-2.35/bfd/elfxx-sparc.c	2020-07-30 15:04:16.719393882 +0100
@@ -1391,7 +1391,8 @@ _bfd_sparc_elf_check_relocs (bfd *abfd,
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  /* A local symbol.  */
-	  isym = bfd_sym_from_r_symndx (&htab->sym_cache, abfd, r_symndx);
+	  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache, abfd,
+					r_symndx);
 	  if (isym == NULL)
 	    return FALSE;
 
diff -rup binutils.orig/bfd/elfxx-sparc.h binutils-2.35/bfd/elfxx-sparc.h
--- binutils.orig/bfd/elfxx-sparc.h	2020-07-30 15:04:05.367466696 +0100
+++ binutils-2.35/bfd/elfxx-sparc.h	2020-07-30 15:04:16.719393882 +0100
@@ -55,9 +55,6 @@ struct _bfd_sparc_elf_link_hash_table
     bfd_vma offset;
   } tls_ldm_got;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* Used by local STT_GNU_IFUNC symbols.  */
   htab_t loc_hash_table;
   void *loc_hash_memory;
diff -rup binutils.orig/bfd/elfxx-tilegx.c binutils-2.35/bfd/elfxx-tilegx.c
--- binutils.orig/bfd/elfxx-tilegx.c	2020-07-30 15:04:05.362466728 +0100
+++ binutils-2.35/bfd/elfxx-tilegx.c	2020-07-30 15:04:16.719393882 +0100
@@ -835,9 +835,6 @@ struct tilegx_elf_link_hash_table
   /* Whether LE transition has been disabled for some of the
      sections.  */
   bfd_boolean disable_le_transition;
-
-  /* Small local sym to section mapping cache.  */
-  struct sym_cache sym_cache;
 };
 
 
@@ -1979,7 +1976,7 @@ tilegx_elf_check_relocs (bfd *abfd, stru
 		  void *vpp;
 		  Elf_Internal_Sym *isym;
 
-		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
+		  isym = bfd_sym_from_r_symndx (&htab->elf.sym_cache,
 						abfd, r_symndx);
 		  if (isym == NULL)
 		    return FALSE;
diff -rup binutils.orig/bfd/elfxx-x86.h binutils-2.35/bfd/elfxx-x86.h
--- binutils.orig/bfd/elfxx-x86.h	2020-07-30 15:04:05.378466625 +0100
+++ binutils-2.35/bfd/elfxx-x86.h	2020-07-30 15:04:16.720393876 +0100
@@ -468,9 +468,6 @@ struct elf_x86_link_hash_table
   /* The amount of space used by the jump slots in the GOT.  */
   bfd_vma sgotplt_jump_table_size;
 
-  /* Small local sym cache.  */
-  struct sym_cache sym_cache;
-
   /* _TLS_MODULE_BASE_ symbol.  */
   struct bfd_link_hash_entry *tls_module_base;
 
